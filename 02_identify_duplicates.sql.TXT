-- ============================================
-- Step 2: Identify Misspelled City Names
-- ============================================

-- Purpose: Use fuzzy matching to identify similar city names that are likely misspellings

-- Enable required PostgreSQL extensions
CREATE EXTENSION IF NOT EXISTS pg_trgm;
CREATE EXTENSION IF NOT EXISTS fuzzystrmatch;
CREATE EXTENSION IF NOT EXISTS unaccent;

-- Query 1: Get basic overview of city name distribution
SELECT 
    COUNT(DISTINCT customer_city) as total_distinct_cities,
    COUNT(*) as total_customer_records,
    ROUND(COUNT(*)::numeric / COUNT(DISTINCT customer_city), 2) as avg_customers_per_city
FROM customers;

-- Query 2: Find cities with highest record counts
SELECT 
    customer_city,
    COUNT(*) as record_count,
    ROUND(COUNT(*) * 100.0 / SUM(COUNT(*)) OVER(), 2) as percentage_of_total
FROM customers
GROUP BY customer_city
ORDER BY record_count DESC
LIMIT 20;

-- Query 3: Identify potential duplicates using fuzzy matching
-- This finds city names that are similar but spelled differently
WITH city_counts AS (
    SELECT 
        customer_city,
        COUNT(*) as record_count,
        LEFT(customer_city, 1) as first_letter
    FROM customers
    GROUP BY customer_city
)
SELECT 
    c1.customer_city as city_1,
    c1.record_count as count_1,
    c2.customer_city as city_2,
    c2.record_count as count_2,
    SIMILARITY(c1.customer_city, c2.customer_city) as similarity_score
FROM city_counts c1
JOIN city_counts c2 ON c1.first_letter = c2.first_letter
WHERE c1.customer_city < c2.customer_city  -- Avoid duplicates and self-comparison
  AND SIMILARITY(c1.customer_city, c2.customer_city) > 0.6  -- Similarity threshold
ORDER BY similarity_score DESC
LIMIT 200;

-- Query 4: Check for simple formatting issues (case, spaces, accents)
WITH cleaned_cities AS (
    SELECT 
        customer_city as original_name,
        UPPER(TRIM(REGEXP_REPLACE(
            UNACCENT(customer_city), 
            '\s+', ' ', 'g'
        ))) as standardized_name,
        COUNT(*) as record_count
    FROM customers
    GROUP BY customer_city
)
SELECT 
    standardized_name,
    STRING_AGG(original_name, ' | ' ORDER BY record_count DESC) as all_variations,
    COUNT(DISTINCT original_name) as num_variations,
    SUM(record_count) as total_records
FROM cleaned_cities
GROUP BY standardized_name
HAVING COUNT(DISTINCT original_name) > 1
ORDER BY total_records DESC
LIMIT 50;